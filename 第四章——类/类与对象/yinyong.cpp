#include<iostream>
using namespace std;

int& func(int& z)
{
	//这里虽然无法对临时变量的地址进行操作，但实际上编译器是为z在栈中创造了一块内存地址，其中存放的是指向外部x的地址，也就是指针。现在操作z，也就相当于c语言中的*z。
	cout << z << endl;
	cout << &z << endl;
	return z;
	//这里返回z引用，和返回一个z变量不同的点在于：普通的变量会先把变量的值赋给一个临时内存区（譬如寄存器），再从这块内存区转到真正的变量。而引用则不需要这块临时空间，
	//而是直接把z所在地址赋给返回处的变量，所以通常要返回的变量，也是通过参数传递进来的外部变。因此可以看出，可以省去一个临时变量的分配过程，这种实现，得益于c++标准以及编译器的实现。
	//TODO：反汇编验证下上面的过程。感觉上面的结论并不正确，实际上还是申请了临时空间，不过保存的是指向变量的指针，因而不需要进行一次copy。
}

int main1()
{
	int x = 33;
	int& p = x;
	p++;
	cout << x << '\t' << p << endl;
	cout << &x << '\t' << &p << endl;//输出相同，说明x,p变量都指向同一地址

	while (1)
	{
		//思考的是这里和函数中实现引用相同否？不同域直接的引用，是否都采用了申请临时空间的方式？
		//可以继续深入，域的实现是通过什么样的机制实现的呢？函数是通过跳转至其他内存空间，函数同样也是局部域，推测类比出块域也如此。
		//但函数之间进行了传值调用，嵌套的块域之间则没有，从这里推测如果没有申请临时空间也是合理的。
		int& s = x;
		s++;
		cout << s << '\t' << x << endl;
		cout << &s << '\t' << &x << endl;
		break;
	}

	int& y = func(x);
	cout << x << endl;
	cout << y << '\t' << &y << endl;

	int z = func(x);
	cout << "z=" << z << endl;


	int test;
	int& test2 = test;//若实参为引用，会出现什么问题？
	func(test2);//寻址到的内容错误，函数中的z参数指向的并非外部test的地址
	//传递的是test2自身引用的地址呢？还是传递的是指向的test地址？目前并非test地址，查看是否为test2引用自身的地址。
	cout << "test2的地址为:" << &test - sizeof(test) << endl;
	//发现确实传递的是引用自身的地址。

	//相当于：
	int t1 = 1;
	int& t2 = t1;
	int& t3 = t2;
	cout << "t3=" << t3 << ",t2指向：" << &t2 << ",t3指向:" << &t3 << endl;
	//但这种就可以正常使用。
	return 0;
}
