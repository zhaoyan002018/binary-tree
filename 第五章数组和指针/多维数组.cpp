#include"common.h"

static char*** func1(char a[][4][5])//数组作为参数时，同样可以省略最高位进行声明，因为在实际运行过程中，会把数组转换成指针进行操作的。
{
	char*** f = (char***)a;
	return f;
}

int main2()
{
	//数组名实际上是数组第一维第一个元素的首地址。
	//因此作为参数时，能省略第一维的数量，但后面维度的数量得指明，因为元素需要知道大小。
	//但返回值时和参数并不相同。
	char a[3][4][5] = { {{1,2,3,4,5}} };
	//C和C++都是采用行排列的存储方式，越靠近右边的下标变化越快。  多维数组是嵌套的，嵌套就是3维数组，套着一群2维数组为元素，同样2维数组套着一群1维数组作为元素。

	//初始化时，可以忽略最高维，由最外层{}内的元素决定长度
	char b[][4][5] = { {0},{0} };
	//char c[][][] = { {0},{0} };不能省略其他低维数组个数
	cout << "b数组的元素个数" << sizeof(b) / sizeof(b[0]) << endl;

	//关于常量指针，只能指向常量，而常量本身是不可被寻址的。int i = &20;应该是因为常量没有固定地址？操作数，在运行时存在。
	const double PI_c = 3.1415926;
	double PI = 3.1415926;
	const double* p = &PI;//常量指针，指向的却可以是变量？
	const double* p2 = &PI_c;
	//*p = 3;
	//*p2 = 3;
	//可想而知，自然而然上面是通不过的，所以常量指针，不一定非要指向常量，只需要我们知道并不想让用户通过这个指针修改被引用处的内容这个功能，便用常量指针即可。

	//const是如何修饰指针的？

	int i = 2, j = 3;
	const int* p_i1;
	int const* p_i2;
	int* const p_i3 = &i;
	//其中1,2 const修饰的是int，也就是常量的是被引用的数据，而非*指针，3修饰的是*,说明3指针，被初始化后便不能修改了，需要声明时就进行初始化。
	//小窍门；const总是修饰它左边的关键字的。
	//p_i3 = &i3;指针常量，指针本身是常量，那么自然不能再进行赋值。


	//数组、指针运算
	int arr[4] = { 1,2,3 ,4 };
	int* arr_p = arr;//数组名，默认被转换为指向第一个元素的指针 常量。
	//char* arr_p = &arr[0];效果一样

	cout << "arr_p=" << *arr_p << endl;
	cout << "*arr_p=" << (void*)arr_p << endl;
	cout << "arr_p++=" << (void*)(arr_p++) << endl;//++作用于cout之后。在表达式起完作用后才执行？。
	cout << "*arr_p=" << (void*)arr_p << endl;
	cout << "*arr_p=" << *arr_p << endl;
	cout << "*arr_p++=" << *arr_p++ << endl;//实际上，输出的并非3.尽管++的优先级更高
	cout << "(*arr_p)++=" << *(arr_p++) << endl;//同第二步，还是3,并非4

	int* arr_p2 = arr;
	int ele = *(arr_p2++);//等效为*arr_p2++
	int ele2 = *arr_p2;
	cout << "ele=" << ele << ",ele2=" << ele2 << endl;//结果为1,2

	int* arr_p3 = arr;
	ele = *++arr_p3;
	ele2 = *arr_p3;
	cout << "ele=" << ele << ",ele2=" << ele2 << endl;//结果为2,2
	//结论，++生效于=表达式之后。所以尽管++优先级高于*，但只能是说++作用于指针，而非*p指向的数据。
	//另外解析声明的顺序，也是先看标识符的右边，再看左边，譬如int* a[5],首先看右边[]他是一个数组，再看*，*必然修饰一个类型，继而看Int ,说明数组里面保存的是int*类型

	//上面对指针自增，增的一位，是按元素的长度进行移动的，对指针sizeof，获得的也是一个元素的长度。错误，获得的是指针的长度。
	cout << "sizeof(arr_p)=" << sizeof(arr_p) << endl;
	cout << "sizeof(int)" << sizeof(int) << "sizeof(*arr_p)=" << sizeof(*arr_p) << endl;//长度为4字节，但发现时间偏移过程中，并没有移动那么多，甚至只有4位。

	int* arr_p4 = arr;
	cout << "*(arr_p4 + 3)=" << *(arr_p4 + 3) << endl;//与++同样是作用于指针，而指针的偏移以元素长度为单位。

	//arr++ 数组名作为指针常量，无法被修改。
	cout << "arr[1 + 1]=" << arr[1 + 1] << endl;
	func1(a);
	return 0;
}
