#include<iostream>
#include<math.h>

using namespace std;

//阶乘的递归实现
//递归分为，递推，回归俩部分
int fac(int n)
{
	//递归函数中俩个重要的组成，1、递归终止条件，2、第n项和n-1项的关系
	if (n == 1)
		return 1;
	return n * fac(n - 1);
}



//共A ,B ,C三个柱子，A有n个盘子，到传给C上面，同时满足大盘在下，小盘在上的规则，问传递的步骤？
//递归终止条件是什么？
//n和n-1的关系是什么？
//A可以选择把盘子给B或C,条件是什么？
//若只有一个盘子在A,直接给C即可
//若有俩个盘子在A,就需要先把最上面的给B,再把第二个给C,再B给C，此时判断的条件时，是否为最后一个盘子？，如果不是，则需要把最上面的盘子（小的）给到B,等A到了最后一个盘子（最大)，放到C上后，再把B的拿出来给到C.
//但上述没有考虑在B柱上，也要满足大盘在下，小盘在上的规则，因为如果A的数量大于2，A在找到最后一个盘子时，会在B柱上放俩个盘子，此时只是拿A上面放B的话，小盘就会在大盘之下了
//这时知道C盘是没有东西的（因为A还没有找到最后一个盘子）,B可以利用C来调整位置,如果A要继续往B放盘子时，发现B上还有盘子，说明将要放的盘子要比B柱所有的盘子都要大。
//当发生递归终止条件时，此时B柱应该是一个除了最后一个盘子的完整汉诺塔，此时把A最后一个大盘放到C柱后，A柱空，B柱成为要变化的位置，利用A柱把B柱的最后一个给C，此时A又成了完成的汉诺塔，而B空，如此往复。

//如何将上述算法抽象出来？
//当新的大盘子要放在B上时，可以先把大盘子放到C上，此时B柱上的盘子都要比A,C柱子小，但C最上面的最后要放到B最下方，所以还是把B的放回A上，怎么放呢？此时B要考虑的和A要考虑的一样，只是A柱子要用B做跳板给C,而此时B柱子要用C为跳板给A

//x是起始柱子，t是跳板，y是要给到的柱子
void printMove(int x, int y)
{
	char a = x, b = y;
	cout << a << "->" << b << endl;
}

enum { ZHU, NUM };
int jumpN;
static void move(int x[], int t[], int y[])//这里的move表示只移动一下呢？还是一直移动，直到整个柱子数量为空？ 如果有跳板时，说明这个是个长动作，而没有跳板说明是一下
{
	int startT;
	if (!t)
		startT = 0;
	else
		startT = t[NUM];
	//跳板的定义是什么？就是当X要给Y盘子时，X并非最后一个时，就需要借助中间柱子把前n-1个放到这个跳板上，而把最后一个盘子从x给到y。
	//这里即希望x能显示出是哪个柱子，也希望传递柱子上的数量
	if (!t)//说明不需要跳板，直接移动即可
	{
		printMove(x[ZHU], y[ZHU]);
		return;
	}

	if (x[NUM] == 1)//若x上的数量为1时，直接给y，不用t作为跳板
	{
		x[NUM]--;
		y[NUM]++;
		move(x, 0, y);
	}

	//当跳板没有盘子时，直接放，否则需要先将跳板上的盘子全部暂时放到另一个盘子上。
	//有跳板时，需要将除最后一个外，剩余的全部给到跳板，最后一个给t。 那具体怎么跳呢？

	else {
		if (t[NUM] == 0)
		{

			x[NUM]--;
			t[NUM]++;
			move(x, 0, t);
		}
		else
		{
			//int tmp = t[NUM];
			move(t, x, y);//把跳板t上的盘子全部放到y上。当有跳板时，实际上不做任何计算，只有当跳板为空时才进行计算？这里终止的条件在结尾x为空，但下面move(y, x, t)的条件不是y为空，x要为空才行。
			//但是x本身就有值啊，此时x作为跳板，也不能通过将x的值清空作为条件，还是要考虑如何计算这里，t的数量。
			x[NUM]--;
			t[NUM]++;
			move(x, 0, t);//放完之后，再从x上拿一个给t。

			//主要是在哪里控制这里move的次数呢？
			//int tmp2 = y[NUM];
			//y[NUM] = tmp;
			move(y, x, t);//将刚才放到y上的盘子，再拿回来给到跳板t。此时这里需要注意当初放了多少，就拿多少，不能少拿或多拿。jumpNl
			//y[NUM] = tmp2 - tmp;
		}
	}

	//上面都是要完成一个动作。
	int xN = x[NUM];
	if (xN)
	{
		move(x, t, y);//这里很关键，需要一直调用，除非把x取完为止,这样move的动作就定型了，只是单纯每次取一个，概念上的短和久，取决于递归次数
		/*
		int tN = t[NUM];
		if (tN > startT)
		{
			move(t, x, y);//问题的关键在这里，不是外层同级的if，而是在进行从x搬运到y结束后，这一动作完成后再去观察跳板t是否还有剩余。
			xN = x[NUM];
			if (xN) {
				move(x, t, y);//这里怎么破呢？答案是在调用之外进行。
				//……
			}
		}
		*/
	}

	//但当x柱子已经空了的时候，若t还有剩余怎么办呢？这里的条件只是做了把x搬空，并没有实现把t也搬空。
	//else if (tN > startT)//这里也同样的问题，因为可能t柱子，本身就有一些，并非一定为空才将他作为跳板。，结束条件不为0，而是如何恢复到初始个数？初始个数在哪？
	//	move(t, x, y);
	else//说明要搬运的柱子已空
		return;
	//如果y本身没有盘子，则直接把x给y，否则要先将y以x为跳板给t。


}

void hanNuoTa(int n)//n表示A柱上盘子的数量
{
	int A[2] = { 'A',0 };
	int B[2] = { 'B',0 };
	int C[2] = { 'C',0 };

	A[NUM] = n;
	while (A[NUM])
	{
		move(A, B, C);//move的动作只是把A清空，而B可能还会有，要实现全部搬运，必须满足A,B都清空才可以。
		if (B[NUM])
			move(B, A, C);
	}
	return;
}

int main1()
{
	//cout << fac(4);
	hanNuoTa(3);
	return 0;
}
